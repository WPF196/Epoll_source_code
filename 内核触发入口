********************************************************************
*****	 		内核触发入口			       *****
********************************************************************
/*
* epoll 机制是通过内核唤醒来进行触发的, 其基本的操作函数主要是 sock_def_readable 和 sock_def_write_space.
* 其中 sock_def_readable 是 EPOLLIN 的触发入口, sock_def_write_space 是 EPOLLOUT 的触发入口.
* 
* 一般当有数据到来时候会执行 sock_def_readable 函数,
* 缓冲区有空间可写入时候会执行 sock_def_write_space 函数, 
* 此处不对函数调用上下文进行分析.
*/

sock_def_readble
{
	sk_has_sleeper(sk);
    
	/*
	其中的 sk_has_sleeper 函数主要用来判断当前 sock 套接字结构中的 sk_sleep 元素上是否有具体的挂载节点.
	挂载点结构为 wait_queue_head_t 结构, 其中的 task_list(struct list_head) 为真正的挂载点.
	挂载 chain 上的节点结构为 eppoll_entry 结构,
	其钩子为内部元素 wait(wait_queue_t结构) , eppoll_entry 中存储有元素 base(struct epitem结构).
	每个挂载点都可以查找到对应的已加入的监听事件, 具体挂载操作在 epoll_ctl 函数中.
	*/
	......
	# define  wake_up_interruptible_sync_poll   __wake_up_sync_key
	......
}

__wake_up_sync_key
{
	// 调用了__wake_up_common函数
}

__wake_up_common
{
	/*
	遍历 sock 结构中的 sk_sleep 上的 task_list 循环链表, 当当前的套接字缓冲区有数据时,需要遍历注册到该 sk_sleep 上的
	所有的监听事件.
	*/

	list_for_each_entry_safe(curr, next, &q->task_list, task_list) {
		/*
		执行每一个 wait_queue_t 结构中的 func 函数, func 函数也是在 epoll_ctl 中进行初始化的.
		此处的 func 函数对应的函数为 ep_poll_callback , 当 func 函数为 default_wake_function 时,
		WQ_FLAG_EXCLUSIVE 可用于内核防止 wake 惊群使用.此处的 func 函数对应 ep_poll_callback.
		做惊群使用时, 每个 epoll_wait 的时候, 会生成一个 wait 结构, 挂载到 ep->wq 链表上.
		既多个 epoll_wait 共同进行时, ep->wq 会挂在多个节点,
		但是 wake 唤醒的时候遇到 WQ_FLAG_EXCLUSIVE 标记退出, 则只唤醒了第一个.
		*/
		if (curr->func(curr, mode, wake_flags, key) &&
				(flags & WQ_FLAG_EXCLUSIVE) &&
				!--nr_exclusive)
	}	
}

/*
curr->func 是在 ep_ptable_queue_proc 函数中进行赋值的,
此处针对 ep_ptable_queue_proc 函数的调用发生在 epoll_ctl 中, 具体分析在 epoll_ctl 函数中进行.
*/

ep_poll_callback
{
	/*
	从 sk_sleep 上得到每一个 wait_queue_t 结构,
	从 wait_queue_t 结构可以得到包含该结构的 epoll_entry 结构.
	eppoll_entry 是由对应的 wait_queue_t 和 epitem 结构组成的.
	*/
	struct epitem *epi = ep_item_from_wait(wait);

	/*
	如果注册过的epi事件中,
	除了EPOLLONESHOT和EPOLLET等特殊标识之外,没有其他的基础标识如EPOLLOUT和EPOLLIN,
	则直接跳出不对此epi事件进行处理.
	*/
	if (!(epi->event.events & ~EP_PRIVATE_BITS))
		goto out_unlock;

	/*
	匹配chain上的每一个epitem里面的events类型(EPOLLIN, EPOLLOUT, EPOLLET,EPOLLLT)是否跟key匹配.
	key里的类型在此处为POLLIN类型, 当然在sock_def_write_space函数里传递过来的为POLLOUT类型.
	*/
	if (key && !((unsigned long) key & epi->event.events))
		goto out_unlock;

	/*
	如果此时ep->ovflist的值不是EP_UNACTIVE_PTR, 说明此刻epoll_wait正在调用ep_scan_ready_list,
	而在ep_scan_ready_list中正在进行内核态向用户态的拷贝操作.
	此时不能直接将epi挂在到ep的rdllist上, 暂时性的挂载到ovflist上.
	*/
	if (unlikely(ep->ovflist != EP_UNACTIVE_PTR)) {
		if (epi->next == EP_UNACTIVE_PTR) {
			epi->next = ep->ovflist;
			ep->ovflist = epi;
		}
		goto out_unlock;
	}

	/*
	判断该epi事件的rdllink链表元素是否为空, 为空的时候则将其挂载到eventpoll主监听集上, 供epoll_wait使用.
	要是该事件的rdllink为非空(已经在rdllist上了), 则不进行挂载.
	*/
	if (!ep_is_linked(&epi->rdllink))
		list_add_tail(&epi->rdllink, &ep->rdllist);

	/*
	当有epoll_wait监听的时候, 会在ep链表上挂载一个wait进程事件,
	当数据到来时候好唤醒沉睡的epoll_wait.
	挂载操作在epoll_wait函数的for(;;)循环之前进行的,
	具体操作在epoll_wait中进行分析.
	*/
	if (waitqueue_active(&ep->wq))
		wake_up_locked(&ep->wq);

	/*
	其中wake_up_locked也会调用上文中提到的__wake_up_common.
	但此处__wake_up_common函数中调用的curr->func则与上文不同.
	ep->wq链表上的节点挂载是在epoll_wait中执行的,在挂载之前对元素func进行了赋值,
	此处调用的是default_wake_function, 该函数主要用于唤醒沉睡的epoll_wait进程,此处不进行具体分析.
	*/
	......
}


sock_def_write_space 函数分析基本同 sock_def_readable 一致, 此处不再进行具体分析.